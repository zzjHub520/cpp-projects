## 1 最大化控制资源成本

![image-20230406212556172](ImagesMarkDown/新题库/image-20230406212556172.png)

公司创新实验室正在研究如何最小化资源成本，最大化资源利用率，请你设计算法帮他们解决一个任务混部问题：有taskNum项任务，每个任务有开始时间（startTime），结束时间（endTime）,并行度（parallelism）三个属性，并行度是指这个任务运行时将会占用的服务器数量，一个服务器在每个时刻可以被任意任务使用但最多被一个任务占用，任务运行完成立即释放（结束时刻不占用）。任务混部问题是指给定一批任务，让这批任务由同一批服务器承载运行，请你计算完成这批任务混部最少需要多少服务器，从而最大最大化控制资源成本。

**输入描述：**

第一行输入为taskNum，表示有taskNum项任务

接下来taskNum行，每行三个整数，表示每个任务的开始时间

（startTime ），结束时间（endTime ），并行度（parallelism）

**输出描述：**

一个整数，表示最少需要的服务器数量

**示例1** 输入输出示例仅供调试，后台判断数据一般不包含示例

输入

3

2 3 1

6 9 2

0 5 1

输出

2

**说明**

一共有三个任务，第一个任务在时间区间【2，3】运行，占用1个服务

器，第二个任务在时间区间【6，9】运行，占用2个服务器，第三个任

务在时间区间【0，5】运行，占用1个服务器，需要最多服务器的时间

区间为【2，3】和【6，9】，需要2个服务器。

**示例2** 输入输出示例仅供调试，后台判断数据一般不包含示例

输入

2

3 9 2

4 7 3

输出

5

**说明**

一共两个任务，第一个任务在时间区间【3，9】运行，占用2个服务

器，第二个任务在时间区间【4，7】运行，占用3个服务器，需要最多

服务器的时间区间为【4，7】，需要5个服务器。

**备注：**

1<=taskNum<=100000

0<=startTime<endTime<=50000

1<=parallelism<=100

```cpp
import java.util.Scanner;
import java.util.*;
import java.util.stream.Collectors;
 
public class Main { 
    public static int max_machine;
 
    public static void main(String[] args) { 
        //处理输入
        Scanner in=new Scanner(System.in); 
        int taskNum = in.nextInt(); 
 
        //构造输入数据结构
        ArrayList<ArrayList<Integer>> outerArrayList = new ArrayList<ArrayList<Integer>>();
 
        for (int i = 0; i < taskNum; i++) {
            int a = in.nextInt();
            int b = in.nextInt();
            int c = in.nextInt();
            ArrayList<Integer> innerArraylist = new ArrayList<Integer>();
            innerArraylist.add(a);
            innerArraylist.add(b);
            innerArraylist.add(c);
            outerArrayList.add(innerArraylist);
            //避免完全没有交集的特殊情况
            if (max_machine < c) {
                max_machine = c;
            }
        }
 
        //递归求交集
        while (outerArrayList.size() > 1) {
            outerArrayList = cal_public_range(outerArrayList);
        }
        System.out.println(max_machine);
    }
 
    public static ArrayList<ArrayList<Integer>> cal_public_range(ArrayList<ArrayList<Integer>> ranges) {
        //先排序 
        Comparator<ArrayList<Integer>> myComparator = new Comparator<ArrayList<Integer>>() {
            @Override
            public int compare(ArrayList<Integer> o1, ArrayList<Integer> o2) {
                if (o1.get(0)!=o2.get(0)){
                        return o1.get(0)-o2.get(0);
                    }else {
                        return o1.get(1)-o2.get(2); 
                    }
            }
        };
        Collections.sort(ranges, myComparator);
 
        //求交集
        ArrayList<ArrayList<Integer>> public_range = new ArrayList<ArrayList<Integer>> ();
        for (int i=0;i<ranges.size();i++) {
            for (int j=i+1;j<ranges.size();j++) {
                int left = Math.max(ranges.get(i).get(0), ranges.get(j).get(0));
                int right = Math.min(ranges.get(i).get(1), ranges.get(j).get(1));
                if (left <= right) {
                    ArrayList<Integer> temp = new ArrayList<Integer>();
                    temp.add(left);
                    temp.add(right);
                    temp.add(ranges.get(i).get(2)+ ranges.get(j).get(2));
                    public_range.add(temp);
                    if (ranges.get(i).get(2)+ ranges.get(j).get(2) > max_machine) {
                        max_machine = ranges.get(i).get(2)+ ranges.get(j).get(2);
                    }
                }
            }
        }
        return public_range;
    }
}
```



## 2 完美走位

![image-20230406212753789](ImagesMarkDown/新题库/image-20230406212753789.png)

![image-20230409015026676](ImagesMarkDown/新题库/image-20230409015026676.png)

![image-20230409015054632](ImagesMarkDown/新题库/image-20230409015054632.png)

> 解题思路
>  1、将字符串转成字典并统计各字符出现次数
>  2、由于题目要求输入的字符数是4的倍数,所以计算各方向需要的次数=字符串总长度/4
>  3、遍历字典，累加字典里已有方向超出各方向需要次数的次数，就是最终需要变换的次数。

```cpp
// 获得完美走位
    func HW2023011() {
        // 测试用例
//        let inputStr = "AASW"
//        let inputStr = "AAAA"
//        let inputStr = "AASAAAAA"
//        let inputStr = "ASDW"
        // 开始代码
        let inputStr = String(readLine()!)
        //  使用高阶函数将字符串转成字典并统计各字符出现次数
        let inputDic = inputStr.reduce(into: [Character: Int]()) { res, key in
            res[key] = Int(res[key] ?? 0) + 1
        }
        let needCount = inputStr.count/4 // 由于题目要求输入的字符数是4的倍数，所以计算各方向需要的次数=字符串总长度/4
        var res = 0 // 最终需要变换的次数
        for (_, v) in inputDic {
            // 累加inputDic里已有方向超出needCount的次数，就是res
            if v > needCount {
                res += (v-needCount)
            }
        }
        print(res)
    }
```



## 3 羊、狼、农夫过河

![image-20230406212923783](ImagesMarkDown/新题库/image-20230406212923783.png)

## 4 字符串重新排列

![image-20230406213136760](ImagesMarkDown/新题库/image-20230406213136760.png)

```cpp
#include <bits/stdc++.h>
 
using namespace std;
 
class Solution {
public:
    string CharacterStatistics(string &s)
    {
        vector<int>array(256,0);
        for (char i : s) {
            array[(int)i]++;
        }
        int maxx = *max_element(array.begin(), array.end());
        string StringBuilder;
        for (int i = maxx; i > 0; i --) {
            for (int j = 97; j < 123; j ++) {
                if (array[j] == i) {
                    StringBuilder.push_back((char)j);
                    StringBuilder.append(":");
                    StringBuilder.append(to_string(i));
                    StringBuilder.append(";");
                }
            }
            for (int j = 65; j < 91; j ++) {
                if (array[j] == i) {
                    StringBuilder.push_back((char)j);
                    StringBuilder.append(":");
                    StringBuilder.append(to_string(i));
                    StringBuilder.append(";");
                }
            }
        }
        return StringBuilder;
    }
};
 
int main(int argc, const char *argv[])
{
    string str;
    getline(cin, str);
    Solution solo;
    cout << solo.CharacterStatistics(str) << endl;
    return 0;
}
```

## 5 租车骑绿岛

![image-20230406213311438](ImagesMarkDown/新题库/image-20230406213311438.png)

## 6 无向图染色

![image-20230406213608727](ImagesMarkDown/新题库/image-20230406213608727.png)

### 解法一：通用方案，DFS

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int M, N;
int ans = 0;
void dfs(int index, vector<vector<int>>& vec, vector<int> &vecColor);
int main()
{
	int tmp1 = 0, tmp2 = 0;
	cin >> M >> N;
	vector<vector<int>>vec(M, vector<int>(M, 0));

	vector<int>vecColor(M, 0);
	for (int i = 0; i < N; ++i)
	{
		cin >> tmp1 >> tmp2;
		vec[tmp1 - 1][tmp2 - 1] = 1;
		vec[tmp2 - 1][tmp1 - 1] = 1;
	}

	dfs(0, vec, vecColor);

	cout << ans << endl;

	return 0;
}
//判断当前节点是否有联通的红色节点
bool isRed(int index, vector<vector<int>>& vec, vector<int> &vecColor)
{
	for (int i = 0; i < M; ++i)
	{
		if (vec[index][i] == 1 /*&& vecFlag[i] == false*/ && vecColor[i] == 1)
		{
			return true;
		}
	}
	return false;
}
void dfs(int index, vector<vector<int>>& vec, vector<int> &vecColor)
{
	if (index == M)
	{
		ans++;
		return;
	}
	//bool flagRed = isRed(index, vec, vecColor);

	if (!isRed(index, vec, vecColor))//判断当前节点是否有联通的红色节点
	{
		//无，当前节点可置为红色或黑色
		vecColor[index] = 1;
		dfs(index + 1, vec, vecColor);
		vecColor[index] = 0;
		dfs(index + 1, vec, vecColor);
	}
	else
	{
		//有，当前节点只可置默认的黑色
		dfs(index + 1, vec, vecColor);
	}
}
```

### 解法二：特殊方案

```
1：数据范围比较小，因此可以考虑暴力破解的方式。
2：图类似的题目，基本就是考察节点和边的处理方式。
节点的表达方式：int -> 二进制数字。举例：1 1000101，1表示红色，0表示黑色
边的表达方式：pair<int, int> 表示两个节点之间相连，存到数组中。
3：有了节点和边，直接遍历所有的可能表达方式即可
```

```cpp
#include<iostream>
#include<vector>
#include<stdlib.h>
#include<algorithm>
#include<string.h>
#include<exception> 
#include<map>
#include<cmath>
#include<unordered_map>
#include<set>
#include<climits>
#include<ctype.h>
#include<queue>
#include<stack>
#include<list>
using namespace std;

int main() {
    //处理输入
    int m, n;
    cin >> m >> n;
    vector<pair<int, int>> edges;
    for (int i = 0; i < n; i++) {
        int a, b;
        cin >> a >> b;
        edges.push_back(make_pair(a, b));
    }

    int count = 0;
    //遍历所有可能的组合 10001 -> i 的二进制表达
    for (int i = 0; i < (1 << m); i++) {
        bool flag = 1;
        // 检测所有的边相连的是否同为红颜色
        for (auto edge : edges) {
            if (((i >> (m-edge.first)) & 1) && ((i >> (m-edge.second)) & 1)) {
                flag = false;
                break;
            }
        }
        if(flag) {
            count++;
        }
    }
    cout << count;
    return 0;
}
```

## 7 单向链表中间节点

![image-20230406222802485](ImagesMarkDown/新题库/image-20230406222802485-16807912847851.png)

## 8 等和子数组最小和

![image-20230406222910971](ImagesMarkDown/新题库/image-20230406222910971.png)

## 9 最多颜色的车辆

![image-20230406223023795](ImagesMarkDown/新题库/image-20230406223023795.png)

## 10 不含 101 的数

![image-20230406223139233](ImagesMarkDown/新题库/image-20230406223139233.png)

## 11 过滤组合字符串

**题目描述：**

数字0、1、2、3、4、5、6、7、8、9分别关联 a~z 26个英文字母。

0 关联 "a","b","c"

1 关联 "d","e","f"

2 关联 "g","h","i"

3 关联 "j","k","l"

4 关联 "m","n","o"

5 关联 "p","q","r"

6 关联 "s","t"

7 关联 "u","v"

8 关联 "w","x"

9 关联 "y","z"

例如7关联"u","v"，8关联"x","w"，输入一个字符串例如“78”，和一个屏蔽字符串“ux”,那么“78”可以组成多个字符串例如：“ux”，“uw”，“vx”，“vw”，过滤这些完全包含屏蔽字符串的每一个字符的字符串，然后输出剩下的字符串。

**示例：**

**输入：**

78

ux

**输出：**

uw vx vw

说明：ux完全包含屏蔽字符串ux，因此剔除

## 12 真正的密码

![image-20230406223724506](ImagesMarkDown/新题库/image-20230406223724506.png)

## 13 最小调整顺序次数

> 给定一个队列，但是这个队列比较特殊，可以从头部添加数据，也可以从尾部添加数据，但是只能从头部删除数据。输入一个数字n，会依次添加数字1~n（也就是添加n次）。
>
> 但是在添加数据的过程中，也会删除数据，要求删除必须按照1~n按照顺序进行删除，所以在删除时，可以根据需要调整队列中数字的顺序以满足删除条件。
> 输入描述：
>
> 第一行一个数据N，表示数据的范围。
>
> 接下来的2N行是添加和删除语句。其中：head add x 表示从头部添加元素 x，tail add
> 表示从尾部添加元素，remove表示删除元素。
>
> 输出描述：
>
> 输出一个数字，表示最小的调整顺序次数。
>
> 示例：
>
> 5
> head add 1
> tail add 2
> remove
> head add 3
> tail add 4
> head add 5
> remove
> remove
> remove
> remove
>
> 输出：
>
> 1
>
> 说明：
>
> 第1步：[1]
>
> 第2步：[1,2]
>
> 第3步：头部删除1，无需调整，还剩[2]
>
> 第4步：[3,2]
>
> 第5步：[3,2,4]
>
> 第6步：[5,3,2,4]
>
> 第7步：头部删除2，调整顺序再删除，还剩[3，4，5]
>
> 第8步：头部删除3，无需调整，还剩[4，5]
>
> 第9步：头部删除4，无需调整，还剩[5]
>
> 第10步：头部删除5，无需调整
>
> 只需要调整1次

```cpp
#include <iostream>
#include <string>
#include <map>
#include <set>
#include <vector>
#include <algorithm>
#include <numeric>

using namespace std;

int main()
{
	int n = 0;
	string operat;

	cin >> n;
	getchar();
	bool isOrder = true;
	int ans = 0;
	int size = 0;
	for (int i = 0; i < 2 * n; ++i)
	{
		getline(cin, operat);
		if (operat.find("remove") != string::npos)
		{
			if (isOrder == false)
			{
				isOrder = true;
				ans++;
			}
		}
		else if (operat.find("head add") != string::npos)
		{
			int pos = operat.rfind(" ");
			int data = stoi(operat.substr(pos + 1));
			if (size)
			{
				isOrder = false;
			}
			size++;
		}
		else if (operat.find("tail add") != string::npos)
		{
			int pos = operat.rfind(" ");
			int data = stoi(operat.substr(pos + 1));
			size++;
		}
	}

	cout << ans << endl;
	return 0;
}
```

## 14 探索地块建立

![image-20230406224307684](ImagesMarkDown/新题库/image-20230406224307684.png)

![image-20230406224406749](ImagesMarkDown/新题库/image-20230406224406749.png)

## 15 模拟商场优惠打折

![image-20230406224440357](ImagesMarkDown/新题库/image-20230406224440357.png)

## 16 区间交叠问题

![image-20230406224524572](ImagesMarkDown/新题库/image-20230406224524572.png)

## 17 二元组个数

给定两个数组a，b，若a[i] == b[j] 则称 [i, j] 为一个二元组，求在给定的两个数组中，二元组的个数。

输入描述：

第一行输入 m

第二行输入m个数，表示第一个数组

第三行输入 n

第四行输入n个数，表示第二个数组

输出描述：

二元组个数。

示例1：

输入：

4

1 2 3 4

1

1

输出：

1

说明：二元组个数为 1个

示例2：

输入：

4

1 1 2 2

3

2 2 4

输出：

4

说明：二元组个数为 4 个 

## 18 最大平分数组

给定一个数组nums，可以将元素分为若干个组，使得每组和相等，求出满足条件的所有分组中，最大的平分组个数。

**输入描述：**

第一行输入 m

接着输入m个数，表示此数组

数据范围:1<=M<=50, 1<=nums[i]<=50

**输出描述：**

最大的平分组数个数。

**示例1：**

输入：

7

4 3 2 3 5 2 1

输出：

4

说明：可以等分的情况有：

4 个子集（5），（1,4），（2,3），（2,3）

2 个子集（5, 1, 4），（2,3, 2,3）

最大的平分组数个数为4个。

**示例2：**

输入：

7

5 2 1 5 2 1 5 2 1

输出：

4

说明：可以等分的情况有：

4 个子集（5，1），（5，1），（5，1），（2，2，2）

2 个子集（5, 1, 5,1），（2,2, 2,5,1）

最大的平分组数个数为4个。



